AWSTemplateFormatVersion: 2010-09-09
Description: >-
  TEST FACILITY ONLY - NOT FOR PRODUCTION USE. This template provisions AWS Organizations, 
  GuardDuty, SecurityHub, and Security Incident Response infrastructure for 
  testing and development purposes. Licensed under MIT-0 (https://github.com/aws/mit-0).
  For guidance on producing product quality foundational security visit the
  AWS Security Reference Architecture

Metadata:
  cfn-lint:
    config:
      ignore_checks:
        - E9007
## Update the default for the sake of automation
Parameters:
  pBaseEmail:
    Type: String
    AllowedPattern: ^[\w+\-.]+@[a-z\d]([a-z\d-]*[a-z\d])?(\.[a-z\d]([a-z\d-]*[a-z\d])?)+$
    ConstraintDescription: Must be a valid email address (e.g., user@example.com)
    Description: Base email address for account notifications (suffixes added automatically)

Resources:
  ###################################
  ## Lambda Role for custom resources
  ###################################
  rReinventC2Role:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Using explicit role name as required by Lambda custom resource."
          - id: W11
            reason: "Resource * is required for this role."
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: reinvent-c2-lambda
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AllowLambdatoAssumeDelegationRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
      Path: /

  ############################
  ## Email Generator
  ############################
  rEmailGeneratorFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permission to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: reinvent-c2-email-generator
      Handler: index.handler
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 30
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import cfnresponse

          def handler(event, context):
            try:
              if event["RequestType"] in ["Create", "Update"]:
                base_email = event["ResourceProperties"]["BaseEmail"]
                account_id = event["ResourceProperties"]["AccountId"]
                
                # Split email into local part and domain
                local_part, domain = base_email.rsplit("@", 1)
                
                # Generate all account-specific emails
                emails = {
                  "HubEmail": f"{local_part}+hub-{account_id}@{domain}",
                  "SandboxEmail": f"{local_part}+sandbox-{account_id}@{domain}",
                  "LogArchiveEmail": f"{local_part}+log-archive-{account_id}@{domain}",
                  "AuditEmail": f"{local_part}+audit-{account_id}@{domain}",
                  "LoggingEmail": f"{local_part}+logging-{account_id}@{domain}",
                  "FacilitatorEmail": base_email,
                  "SecondaryEmail": f"{local_part}+secondary@{domain}",
                }
                
                cfnresponse.send(event, context, cfnresponse.SUCCESS, emails)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
            except Exception as e:
              cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})

  rEmailGenerator:
    Type: Custom::EmailGenerator
    Properties:
      ServiceToken: !GetAtt rEmailGeneratorFunction.Arn
      BaseEmail: !Ref pBaseEmail
      AccountId: !Ref AWS::AccountId

  ############################
  ## Ensures
  ############################
  rInventoryCustomResource:
    DependsOn:
      - rOrganization
    Type: Custom::Inventory
    Properties:
      ServiceToken: !GetAtt rInventoryFunction.Arn

  rInventoryFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permission to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: reinvent-c2-inventory
      Handler: index.handler
      # amazonq-ignore-next-line
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 300
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time

          def get_aws_org_details(event, context):
            orgs = boto3.client('organizations')
            try:
              response = orgs.describe_organization()
              response_root = orgs.list_roots()
              organization_root_id = response_root['Roots'][0]['Id']
              print(f"AWS Org Root OU ID: {organization_root_id}")
              organization_id = response['Organization']['Id']
              print(f"AWS Org ID: {organization_id}")
              master_account_arn = response['Organization']['MasterAccountArn']
              master_account_id = master_account_arn.split('/')[-1]
              master_account_email = response['Organization']['MasterAccountEmail']
              print(f"Identified Management Account ID: {master_account_id}")
              responseData = {}
              responseData['AwsOrgId'] = organization_id
              responseData['AwsRootOuId'] = organization_root_id
              responseData['AwsManagementAccountId'] = master_account_id
              responseData['AwsManagementAccountEmail'] = master_account_email
              cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
            except Exception as e:
              print(f"An error occurred: {e}")
              cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)

          def handler(event, context):
            try:
              if event["RequestType"] == "Create" or event["RequestType"] == "Update":
                time.sleep(120) # let control tower wrap up accounts
                get_aws_org_details(event, context)
              elif event["RequestType"] == "Delete":
                print("Leaving params and removing resource")
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
              else:
                raise ValueError("Invalid request type: %s" % event["RequestType"])
            except Exception as e:
              print(f"An error occurred: {e}")
              cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)

  ############################
  ## ORGANIZATIONS
  ############################

  ###############################
  # ENABLE ORG SERVICES
  ###############################
  EnableTrustedAccess:
    Type: Custom::EnableTrustedAccess
    Properties:
      ServiceToken: !GetAtt EnableTrustedAccessFunction.Arn
      OrganizationId: !GetAtt rInventoryCustomResource.AwsOrgId

  EnableTrustedAccessFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permissions to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    DependsOn:
        - rOrganization
    Properties:
      Handler: index.handler
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 60
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
            try:
              logger.info("Received event: %s" % event)
              organization_id = event["ResourceProperties"]["OrganizationId"]
              organizations = boto3.client("organizations")
              cloudformation = boto3.client("cloudformation")
              if event["RequestType"] == "Create" or event["RequestType"] == "Update":
                # Enable trusted access for CloudFormation on the organization
                try:
                  organizations.enable_aws_service_access(ServicePrincipal="member.org.stacksets.cloudformation.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="account.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="securityhub.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="malware-protection.guardduty.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="guardduty.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="security-ir.amazonaws.com")
                except Exception as e:
                  logger.info("failed, but trying again in 10 seconds")
                  time.sleep(10)
                  organizations.enable_aws_service_access(ServicePrincipal="member.org.stacksets.cloudformation.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="account.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="malware-protection.guardduty.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="securityhub.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="guardduty.amazonaws.com")
                  organizations.enable_aws_service_access(ServicePrincipal="security-ir.amazonaws.com")
                logger.info("Enabled trusted access for CloudFormation on organization %s" % organization_id)
                time.sleep(10)
                cloudformation.activate_organizations_access();
              elif event["RequestType"] == "Delete":
                logger.info("Removing custom resource but leaving service enabled %s" % organization_id)
              else:
                raise ValueError("Invalid request type: %s" % event["RequestType"])
              # Send success response to CloudFormation
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
            except Exception as e:
              logger.error("Error: %s" % e)
              # Send failure response to CloudFormation
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, event["LogicalResourceId"])

  #########################
  # CLOUDFORMATION SETUP
  #########################
  rAWSCloudFormationStackSetExecutionRole: # pStackExecutionRole
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Role name is required by AWS CloudFormation Role resource."
    Type: AWS::IAM::Role
    Properties:
      RoleName: AWSCloudFormationStackSetExecutionRole
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS:
                - !Ref AWS::AccountId
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess

  SelfManagedExecutorRole:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Role name is required by AWS CloudFormation Role resource."
    Type: AWS::IAM::Role
    Properties:
      RoleName: AWSCloudFormationStackSetAdministrationRole
      Description: self managed cloudformation role for AWS Organization
      AssumeRolePolicyDocument:
        Statement:
        - Action: sts:AssumeRole
          Effect: Allow
          Principal:
            Service: cloudformation.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
      Policies:
      - PolicyName: AssumeRoleAWSCloudFormationStackSetExecutionRole
        PolicyDocument:
            Statement:
            - Action: sts:AssumeRole
              Effect: Allow
              Resource: arn:*:iam::*:role/AWSCloudFormationStackSetExecutionRole
            Version: '2012-10-17'

  #########################
  # Member Account Execution Role StackSet
  #########################
  rMemberAccountExecutionRoleStackSet:
    Type: AWS::CloudFormation::StackSet
    DependsOn:
      - EnableTrustedAccess
      - rSecurityAccount
      - rLoggingAccount
    Properties:
      StackSetName: member-account-execution-role
      CallAs: SELF
      PermissionModel: SERVICE_MANAGED
      AutoDeployment:
        Enabled: true
        RetainStacksOnAccountRemoval: false
      Capabilities:
        - CAPABILITY_NAMED_IAM
      Description: 'Deploys AWSCloudFormationStackSetExecutionRole to member accounts'
      OperationPreferences:
        FailureTolerancePercentage: 0
        MaxConcurrentPercentage: 100
        RegionConcurrencyType: PARALLEL
      StackInstancesGroup:
        - DeploymentTargets:
            OrganizationalUnitIds:
              - !GetAtt rInventoryCustomResource.AwsRootOuId
          Regions:
            - !Ref AWS::Region
      Parameters:
        - ParameterKey: pManagementAccountId
          ParameterValue: !Ref AWS::AccountId
      TemplateBody: |
        Parameters:
          pManagementAccountId:
            Type: String
            Description: Management Account ID
        Resources:
          rExecutionRole:
            Type: AWS::IAM::Role
            Properties:
              RoleName: AWSCloudFormationStackSetExecutionRole
              AssumeRolePolicyDocument:
                Version: 2012-10-17
                Statement:
                  - Effect: Allow
                    Principal:
                      AWS:
                        - !Ref pManagementAccountId
                    Action:
                      - sts:AssumeRole
              Path: /
              ManagedPolicyArns:
                - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess

  #########################
  # GuardDuty SETUP
  #########################
  rGuardDutyServiceLinkedRoles:
    Type: Custom::GuardDutyServiceLinkedRoles
    Properties:
      ServiceToken: !GetAtt rGuardDutyServiceLinkedRolesFunction.Arn

  rGuardDutyServiceLinkedRolesFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permissions to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 60
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
            try:
              logger.info("Received event: %s" % event)
              iam = boto3.client('iam')
              
              if event["RequestType"] == "Create":
                # Check and create GuardDuty SLR
                try:
                  iam.get_role(RoleName='AWSServiceRoleForAmazonGuardDuty')
                  logger.info("GuardDuty service-linked role already exists")
                except ClientError as e:
                  if e.response['Error']['Code'] == 'NoSuchEntity':
                    logger.info("Creating GuardDuty service-linked role")
                    iam.create_service_linked_role(
                      AWSServiceName='guardduty.amazonaws.com',
                      Description='A service-linked role required for Amazon GuardDuty to access your resources'
                    )
                  else:
                    raise e
                
                # Check and create GuardDuty Malware Protection SLR
                try:
                  iam.get_role(RoleName='AWSServiceRoleForAmazonGuardDutyMalwareProtection')
                  logger.info("GuardDuty Malware Protection service-linked role already exists")
                except ClientError as e:
                  if e.response['Error']['Code'] == 'NoSuchEntity':
                    logger.info("Creating GuardDuty Malware Protection service-linked role")
                    iam.create_service_linked_role(
                      AWSServiceName='malware-protection.guardduty.amazonaws.com',
                      Description='A service-linked role required for Amazon GuardDuty to access your resources.'
                    )
                  else:
                    raise e
                
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              elif event["RequestType"] == "Update" or event["RequestType"] == "Delete":
                # Do nothing on update or delete
                logger.info("No action needed for %s" % event["RequestType"])
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              else:
                raise ValueError("Invalid request type: %s" % event["RequestType"])
            except Exception as e:
              logger.error("Error: %s" % e)
              cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

  rGuardDutyStackSet:
    Type: AWS::CloudFormation::StackSet
    DependsOn:
      - rEnableDelegatedAdminGD
      - EnableTrustedAccess
      - rAWSCloudFormationStackSetExecutionRole
      - rGuardDutyServiceLinkedRoles
      - rMemberAccountExecutionRoleStackSet
    Properties:
      StackSetName: sra-guardduty
      CallAs: SELF
      PermissionModel: SELF_MANAGED
      Capabilities:
        - CAPABILITY_NAMED_IAM
      Description: 'Deploys an IAM role for configuring GuardDuty'
      OperationPreferences:
        FailureTolerancePercentage: 0
        MaxConcurrentPercentage: 100
        RegionConcurrencyType: PARALLEL
      StackInstancesGroup:
        - DeploymentTargets:
            Accounts:
              - !Ref rSecurityAccount
          Regions:
            - !Ref AWS::Region
      Parameters:
        - ParameterKey: pLoggingAccountId
          ParameterValue: !Ref rLoggingAccount
        - ParameterKey: pLoggingAccountEmail
          ParameterValue: !GetAtt rEmailGenerator.LoggingEmail
        - ParameterKey: pManagementAccountId
          ParameterValue: !Ref AWS::AccountId
        - ParameterKey: pManagementAccountEmail
          ParameterValue: !GetAtt rInventoryCustomResource.AwsManagementAccountEmail
      TemplateBody: |
        Parameters:
          pLoggingAccountId:
            AllowedPattern: '^\d{12}$'
            ConstraintDescription: Must be 12 digits
            Description: Logging Management Account ID
            Type: String
          pLoggingAccountEmail:
            Type: String
            AllowedPattern: ^[\w+\-.]+@[a-z\d\-.]+\.[a-z]+$
            Description: Logging Account Email Address
          pManagementAccountId:
            AllowedPattern: '^\d{12}$'
            ConstraintDescription: Must be 12 digits
            Description: Management Account ID
            Type: String
          pManagementAccountEmail:
            Type: String
            AllowedPattern: ^[\w+\-.]+@[a-z\d\-.]+\.[a-z]+$
            Description: Management Account Email Address
        Resources:
          rDetectorRole:
            Type: AWS::IAM::Role
            Properties:
              RoleName: DetectorCR2
              AssumeRolePolicyDocument:
                Version: 2012-10-17
                Statement:
                  - Effect: Allow
                    Principal:
                      Service: lambda.amazonaws.com
                    Action:
                      - "sts:AssumeRole"
              ManagedPolicyArns:
                - !Join [ ":", [ "arn", !Ref AWS::Partition, "iam", "", "aws", "policy/AdministratorAccess" ] ]
          rDetectorCustomResource:
            Type: Custom::UpdateDetector
            Properties:
              ServiceToken: !GetAtt rDetectorFunction.Arn
              Nonce: ATTEMPT-2
              ServiceTimeout: 120
          rAddLoggingAccount:
            Type: Custom::CreateMember
            DependsOn:
              - rDetectorCustomResource
            Properties:
              ServiceToken: !GetAtt rMemberFunction.Arn
              AccountId: !Ref pLoggingAccountId
              AccountEmail: !Ref pLoggingAccountEmail
              ServiceTimeout: 120
          rAddManagementAccount:
            Type: Custom::CreateMember
            DependsOn:
              - rDetectorCustomResource
            Properties:
              ServiceToken: !GetAtt rMemberFunction.Arn
              AccountId: !Ref pManagementAccountId
              AccountEmail: !Ref pManagementAccountEmail
              ServiceTimeout: 120
          rMemberFunction:
            Type: AWS::Lambda::Function
            Properties:
              Handler: index.handler
              Runtime: python3.13
              Timeout: 300
              Role: !GetAtt rDetectorRole.Arn
              Code:
                ZipFile: |
                  import json
                  import boto3
                  import cfnresponse
                  import time
        
                  guardduty_client = boto3.client('guardduty')
        
                  def handler(event, context):
                      try:
                          account_id = event["ResourceProperties"]["AccountId"]
                          account_email = event["ResourceProperties"]["AccountEmail"]
                          response = guardduty_client.list_detectors()
                          detector_id = response['DetectorIds'][0]
                          if event["RequestType"] == "Create" :
                              guardduty_client.create_members(
                                DetectorId=detector_id,
                                AccountDetails=[
                                  {
                                    'AccountId': account_id,
                                    'Email':account_email
                                  }
                                ]
                              )
                              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                          elif event["RequestType"] == "Delete" or event["RequestType"] == "Update":
                              print("Leaving params and removing resource")
                              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                          else:
                              raise ValueError("Invalid request type: %s" % event["RequestType"])
                      except Exception as e:
                          print(f"An error occurred: {e}")
                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)
          rDetectorFunction:
            Type: AWS::Lambda::Function
            Properties:
              Handler: index.handler
              Runtime: python3.13
              Timeout: 300
              Role: !GetAtt rDetectorRole.Arn
              Code:
                ZipFile: |
                  import json
                  import boto3
                  import cfnresponse
                  import time
        
                  guardduty_client = boto3.client('guardduty')
        
        
                  def update_detector(event, context):
                      orgs = boto3.client('organizations')
                      try:
                          response = guardduty_client.list_detectors()
                          detector_id = response['DetectorIds'][0]
                          print(f"Detector ID: {detector_id}")
                          responseData = {}
                          responseData['AdminDetectorId'] = detector_id
                          guardduty_client.update_detector(
                              DetectorId=detector_id,
                              Features=[
                              {
                                  'Name': 'S3_DATA_EVENTS',
                                  'Status': 'ENABLED'
                              },
                              {
                                  'Name': 'EBS_MALWARE_PROTECTION',
                                  'Status': 'ENABLED'
                              }
                          ])
                          guardduty_client.update_organization_configuration(
                              DetectorId=detector_id,
                              AutoEnableOrganizationMembers='ALL',
                          )
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)
                      except Exception as e:
                          print(f"An error occurred: {e}")
                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)
        
        
                  def handler(event, context):
                      try:
                          if event["RequestType"] == "Create" or event["RequestType"] == "Update":
                              update_detector(event, context)
                          elif event["RequestType"] == "Delete":
                              print("Leaving params and removing resource")
                              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                          else:
                              raise ValueError("Invalid request type: %s" % event["RequestType"])
                      except Exception as e:
                          print(f"An error occurred: {e}")
                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)
  rGuardDutyConfigurationIAMRoleStackSet:
    Type: AWS::CloudFormation::StackSet
    DependsOn:
      - EnableTrustedAccess
      - rAWSCloudFormationStackSetExecutionRole
      - rMemberAccountExecutionRoleStackSet
    Properties:
      StackSetName: sra-guardduty-org-configuration-role
      CallAs: SELF
      PermissionModel: SELF_MANAGED
      Capabilities:
        - CAPABILITY_NAMED_IAM
      Description: 'Deploys an IAM role for configuring GuardDuty'
      OperationPreferences:
        FailureTolerancePercentage: 0
        MaxConcurrentPercentage: 100
        RegionConcurrencyType: PARALLEL
      StackInstancesGroup:
        - DeploymentTargets:
            Accounts:
              - !Ref rSecurityAccount
          Regions:
            - !Ref AWS::Region
      Parameters:
        - ParameterKey: pManagementAccountId
          ParameterValue: !Ref AWS::AccountId
        - ParameterKey: pGuardDutyOrgLambdaRoleArn
          ParameterValue: !GetAtt SelfManagedExecutorRole.Arn
      TemplateBody: |
        Parameters:
          pGuardDutyOrgConfigurationRoleName:
            AllowedPattern: '^[\w+=,.@-]{1,64}$'
            ConstraintDescription: Max 64 alphanumeric characters. Also special characters supported [+, =, ., @, -]
            Default: sra-guardduty-org-configuration
            Description: GuardDuty Configuration IAM Role Name
            Type: String
          pManagementAccountId:
            AllowedPattern: '^\d{12}$'
            ConstraintDescription: Must be 12 digits
            Description: Organization Management Account ID
            Type: String
          pGuardDutyOrgLambdaRoleArn:
            AllowedPattern: '^arn:aws[a-zA-Z-]*:iam::[0-9]{12}:role/[a-zA-Z0-9+=,.@\-_/]+$'
            ConstraintDescription: Must be a valid IAM Role ARN
            Description: Lambda Role Name
            Type: String
          pSRASolutionName:
            AllowedValues: [sra-guardduty-org]
            Default: sra-guardduty-org
            Description: The SRA solution name. The default value is the folder name of the solution
            Type: String

        Resources:
          rConfigurationRole:
            Type: AWS::IAM::Role
            Metadata:
              cfn_nag:
                rules_to_suppress:
                  - id: W11
                    reason: Actions require * in resource
                  - id: W28
                    reason: Explicit role name provided
              checkov:
                skip:
                  - id: CKV_AWS_111
                    comment: IAM write actions require wildcard in resource
            Properties:
              RoleName: !Ref pGuardDutyOrgConfigurationRoleName
              AssumeRolePolicyDocument:
                Version: 2012-10-17
                Statement:
                  - Effect: Allow
                    Action: sts:AssumeRole
                    Condition:
                      StringEquals:
                        aws:PrincipalArn:
                          - !Ref pGuardDutyOrgLambdaRoleArn
                    Principal:
                      AWS:
                        - !Sub arn:${AWS::Partition}:iam::${pManagementAccountId}:root
              Path: '/'
              Policies:
                - PolicyName: sra-guardduty-org-policy-organizations
                  PolicyDocument:
                    Version: 2012-10-17
                    Statement:
                      - Sid: OrganizationsListAccounts
                        Effect: Allow
                        Action: organizations:ListAccounts
                        Resource: '*'

                - PolicyName: sra-guardduty-org-policy-guardduty
                  PolicyDocument:
                    Version: 2012-10-17
                    Statement:
                      - Sid: GuardDutyNoResource
                        Effect: Allow
                        Action: guardduty:ListDetectors
                        Resource: '*'

                      - Sid: GuardDutyWithResource
                        Effect: Allow
                        Action:
                          - guardduty:CreateMembers
                          - guardduty:CreatePublishingDestination
                          - guardduty:DeleteDetector
                          - guardduty:DeleteMembers
                          - guardduty:DisassociateMembers
                          - guardduty:ListMembers
                          - guardduty:ListPublishingDestinations
                          - guardduty:UpdateDetector
                          - guardduty:UpdateMemberDetectors
                          - guardduty:UpdateOrganizationConfiguration
                          - guardduty:UpdatePublishingDestination
                        Resource:
                          - !Sub arn:${AWS::Partition}:guardduty:*:${AWS::AccountId}:/detector/*
                          - !Sub arn:${AWS::Partition}:guardduty:*:${AWS::AccountId}:detector/*

                - PolicyName: sra-guardduty-org-policy-iam
                  PolicyDocument:
                    Version: 2012-10-17
                    Statement:
                      - Sid: AllowReadIamActions
                        Effect: Allow
                        Action: iam:GetRole
                        Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/*

                      - Sid: AllowCreateDeleteServiceLinkedRole
                        Effect: Allow
                        Action:
                          - iam:CreateServiceLinkedRole
                          - iam:DeleteServiceLinkedRole
                        Condition:
                          StringLike:
                            iam:AWSServiceName:
                              - guardduty.amazonaws.com
                              - malware-protection.guardduty.amazonaws.com
                        Resource:
                          - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/guardduty.amazonaws.com/AWSServiceRoleForAmazonGuardDuty
                          - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/malware-protection.guardduty.amazonaws.com/AWSServiceRoleForAmazonGuardDutyMalwareProtection

                      - Sid: AllowPolicyActions
                        Effect: Allow
                        Action:
                          - iam:DeleteRolePolicy
                          - iam:PutRolePolicy
                        Resource:
                          - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/guardduty.amazonaws.com/AWSServiceRoleForAmazonGuardDuty
                          - !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/malware-protection.guardduty.amazonaws.com/AWSServiceRoleForAmazonGuardDutyMalwareProtection

                      - Sid: AllowEnableMalwareProtection
                        Effect: Allow
                        Action:
                          - organizations:EnableAWSServiceAccess
                          - organizations:RegisterDelegatedAdministrator
                          - organizations:ListDelegatedAdministrators
                          - organizations:ListAWSServiceAccessForOrganization
                          - organizations:DescribeOrganizationalUnit
                          - organizations:DescribeAccount
                          - organizations:DescribeOrganization
                        Resource: '*'
                      
                      - Sid: AllowSecretsManagerReadonly
                        Effect: Allow
                        Action:                          
                          - secretsmanager:GetSecretValue
                          - secretsmanager:DescribeSecret
                        Resource: '*'
                      
                      - Sid: AllowGetRoleMalwareProtection
                        Effect: Allow
                        Action:
                          - iam:GetRole
                        Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/malware-protection.guardduty.amazonaws.com/AWSServiceRoleForAmazonGuardDutyMalwareProtection
              Tags:
                - Key: sra-solution
                  Value: !Ref pSRASolutionName

      Tags:
        - Key: sra-solution
          Value: 'sir-workshop'

  rEnableDelegatedAdminGD:
    DependsOn:
      - EnableTrustedAccess
      - rOrganization
    Type: Custom::EnableGDDAdmin
    Properties:
      ServiceToken: !GetAtt rEnableDelegatedAdminLambdaGD.Arn
      SecurityAccountId: !Ref rSecurityAccount
      ServiceTimeout: 120

  # Role for Delegate Admin Custom Resource. Only triggers if in the Security Account
  rEnableDelegateAdminRoleGD:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Role name is set to a static, unique value to avoid conflicts with other resources"
    Type: AWS::IAM::Role
    Properties:
      RoleName: EnableGuardDutyCR
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - !Sub "arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess"

  # Lambda for Delegate Admin Custom Resource. Only triggers if in the Security Account
  rEnableDelegatedAdminLambdaGD:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permissions to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt rEnableDelegateAdminRoleGD.Arn
      Handler: index.handler
      Timeout: 60
      # amazonq-ignore-next-line
      Runtime: python3.13
      Code:
        ZipFile: |
          import boto3
          from botocore.exceptions import ClientError
          import cfnresponse
          import json
          import logging
          from time import sleep

          logger = logging.getLogger("sir-workshop")

          guardduty_client = boto3.client("guardduty")
          organizations = boto3.client("organizations")

          def handler(event, context):

            if event["RequestType"] == "Create":
              logger.info(json.dumps(event))
              security_account_id = event["ResourceProperties"]["SecurityAccountId"]
              logger.info(security_account_id)
              try:
                guardduty_client.enable_organization_admin_account(AdminAccountId=security_account_id)
                logger.info('Successful Enabling Admin Account')
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
              except ClientError as error:
                logger.error(error)
            
                if 'already enabled' in error.response['Error']['Message']:
                  logger.info(f"Delegated admin '{security_account_id}' enabled")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])    

                elif error.response["Error"]["Code"] == "BadRequestException":
                  sleep(60)
                  guardduty_client.enable_organization_admin_account(AdminAccountId=security_account_id)
                  logger.info(f"Delegated admin '{security_account_id}' enabled")
                elif error.response["Error"]["Code"] != "InvalidInputException":
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, event["LogicalResourceId"])
                  raise
                else:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, event["LogicalResourceId"])
            elif event["RequestType"] == "Delete" or event["RequestType"] == "Update":
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
            else:
              raise ValueError("Invalid request type: %s" % event["RequestType"])
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, event["LogicalResourceId"])

  #######################################
  ## CONTROL TOWER
  ######################################
  rOrganization: # pOrganizationId
    Type: 'AWS::Organizations::Organization'
    Properties:
      FeatureSet: ALL

  rLoggingAccount: # pLogArchiveAccountId
    Type: 'AWS::Organizations::Account'
    DependsOn:
      - rOrganization
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Properties:
      AccountName: "Log Archive"
      Email: !GetAtt rEmailGenerator.LogArchiveEmail

  rSecurityAccount: # pAuditAccountId
    Type: 'AWS::Organizations::Account'
    DependsOn:
      - rOrganization
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    Properties:
      AccountName: 'Audit'
      Email: !GetAtt rEmailGenerator.AuditEmail

  #########################
  # SecurityHub SETUP
  #########################
  rSecurityHub:
    Type: AWS::SecurityHub::Hub
  rEnableDelegatedAdminSH:
    DependsOn:
      - EnableTrustedAccess
      - rSecurityHub
      - rOrganization
    Type: AWS::SecurityHub::DelegatedAdmin
    Properties:
      AdminAccountId: !Ref rSecurityAccount
  rSecurityHubStackSet:
    Type: AWS::CloudFormation::StackSet
    DependsOn:
      - rEnableDelegatedAdminSH
      - EnableTrustedAccess
      - rAWSCloudFormationStackSetExecutionRole
      - rMemberAccountExecutionRoleStackSet
    Properties:
      StackSetName: sra-securityhub
      CallAs: SELF
      PermissionModel: SELF_MANAGED
      Capabilities:
        - CAPABILITY_NAMED_IAM
      Description: 'Deploys an IAM role for configuring GuardDuty'
      OperationPreferences:
        FailureTolerancePercentage: 0
        MaxConcurrentPercentage: 100
        RegionConcurrencyType: PARALLEL
      StackInstancesGroup:
        - DeploymentTargets:
            Accounts:
              - !Ref rSecurityAccount
          Regions:
            - !Ref AWS::Region
      TemplateBody: |
        Resources:
          rOrganizationConfiguration:
            Type: AWS::SecurityHub::OrganizationConfiguration
            Properties:
              AutoEnable: true
  
  #########################
  # Security Incident Response SETUP
  #########################
  rSirServiceLinkedRoles:
    Type: Custom::SirServiceLinkedRoles
    Properties:
      ServiceToken: !GetAtt rSirServiceLinkedRolesFunction.Arn

  rSirServiceLinkedRolesFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permissions to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 60
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
            try:
              logger.info("Received event: %s" % event)
              iam = boto3.client('iam')
              
              if event["RequestType"] == "Create":
                # Check and create Sir SLR
                try:
                  iam.get_role(RoleName='AWSServiceRoleForSecurityIncidentResponse_Triage')
                  logger.info("Sir service-linked role already exists")
                except ClientError as e:
                  if e.response['Error']['Code'] == 'NoSuchEntity':
                    logger.info("Creating Sir service-linked role")
                    iam.create_service_linked_role(
                      AWSServiceName='triage.security-ir.amazonaws.com',
                      Description='A service-linked role required for Amazon Sir to access your resources'
                    )
                  else:
                    raise e
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              elif event["RequestType"] == "Update" or event["RequestType"] == "Delete":
                # Do nothing on update or delete
                logger.info("No action needed for %s" % event["RequestType"])
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              else:
                raise ValueError("Invalid request type: %s" % event["RequestType"])
            except Exception as e:
              logger.error("Error: %s" % e)
              cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})


  rDelegateAdminSIR:
    DependsOn:
      - rOrganization
      - EnableTrustedAccess
    Type: Custom::DelegateSIR
    Properties:
      ServiceToken: !GetAtt rEnableSIRDGFunction.Arn
      DelegatedAdministratorAccountId: !Ref rSecurityAccount    

  rEnableSIRDGFunction:
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W92
            reason: "Lambda ReservedConcurrentExecutions not required for this function."
          - id: W89
            reason: "VPC Access not required for this function."
          - id: W58
            reason: "Permissions to write to CloudWatch Logs not required for this function."
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: enable-sir-dg
      Handler: index.handler
      # amazonq-ignore-next-line
      Runtime: python3.13
      Timeout: 300
      Role: !GetAtt rReinventC2Role.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time

          client = boto3.client('organizations')


          def handler(event, context):
            delegated_administrator_account_id = event['ResourceProperties']['DelegatedAdministratorAccountId']
            try:
              if event["RequestType"] == "Create":
                time.sleep(120) # let control tower wrap up accounts
                client.register_delegated_administrator(
                  AccountId=delegated_administrator_account_id,
                  ServicePrincipal='security-ir.amazonaws.com'
                )
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
              elif event["RequestType"] == "Update":
                print("No action on update")
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
              elif event["RequestType"] == "Delete":
                print("Leaving params and removing resource")
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
              else:
                raise ValueError("Invalid request type: %s" % event["RequestType"])
            except Exception as e:
              print(f"An error occurred: {e}")
              cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)
  rSirStackSet:
    Type: AWS::CloudFormation::StackSet
    DependsOn:
      - rSecurityHubStackSet
      - rGuardDutyStackSet
      - rDelegateAdminSIR
    Properties:
      StackSetName: enable-sir
      CallAs: SELF
      PermissionModel: SELF_MANAGED
      Capabilities:
        - CAPABILITY_NAMED_IAM
      Description: 'Deploys a Security Incident Response Membership to the Security Account'
      OperationPreferences:
        FailureTolerancePercentage: 0
        MaxConcurrentPercentage: 100
        RegionConcurrencyType: PARALLEL
      StackInstancesGroup:
        - DeploymentTargets:
            Accounts:
              - !Ref rSecurityAccount
          Regions:
            - !Ref AWS::Region
      Parameters:
        - ParameterKey: pFacilitatorEmail
          ParameterValue: !GetAtt rEmailGenerator.FacilitatorEmail
        - ParameterKey: pSecondaryEmail
          ParameterValue: !GetAtt rEmailGenerator.SecondaryEmail
        - ParameterKey: pManagementAccountId
          ParameterValue: !Ref "AWS::AccountId"
      TemplateBody: |
        Parameters:
          pFacilitatorEmail:
            Type: String
            AllowedPattern: ^[\w+\-.]+@[a-z\d\-.]+\.[a-z]+$
            Description: Primary facilitator email address
          pSecondaryEmail:
            Type: String
            AllowedPattern: ^[\w+\-.]+@[a-z\d\-.]+\.[a-z]+$
            Description: Secondary facilitator email address
          pManagementAccountId:
            Type: String

        Resources:
          rReinventC2Role:
            Metadata:
              cfn_nag:
                rules_to_suppress:
                  - id: W11
                    reason: "Resource * is required for this role."
            Type: "AWS::IAM::Role"
            Properties:
              RoleName: enable-sir-role
              AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Sid: AllowLambdatoAssumeDelegationRole
                    Effect: Allow
                    Principal:
                      Service: lambda.amazonaws.com
                    Action:
                      - "sts:AssumeRole"
              ManagedPolicyArns:
                - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
              Path: /
          
          rEnableSIR:
            Type: Custom::Inventory
            Properties:
              ServiceToken: !GetAtt rEnableSIRFunction.Arn
              FacilitatorEmail: !Ref pFacilitatorEmail
              SecondaryEmail: !Ref pSecondaryEmail
              ManagementAccountId: !Ref pManagementAccountId

          rEnableSIRFunction:
            Type: AWS::Lambda::Function
            Properties:
              FunctionName: enable-sir-function
              Handler: index.handler
              Runtime: python3.13
              Timeout: 300
              Role: !GetAtt rReinventC2Role.Arn
              Code:
                ZipFile: |
                  import json
                  import boto3
                  import cfnresponse
                  import time
                  from datetime import datetime

                  client = boto3.client('security-ir')


                  def handler(event, context):
                    facilitator_email = event['ResourceProperties']['FacilitatorEmail']
                    secondary_email = event['ResourceProperties']['SecondaryEmail']
                    management_account_id = event['ResourceProperties']['ManagementAccountId']
                    person1 = {'name': 'Facilitator', 'jobTitle': 'Facilitator', 'email': facilitator_email}
                    person2 = {'name': 'Facilitator', 'jobTitle': 'Facilitator', 'email': secondary_email}
                    opt_in_features = [{'featureName': 'Triage', 'isEnabled': True}]
                    current_date = datetime.now().strftime("%Y-%m-%d")
                    membership_name = f'[WWSO_WORKSHOP {current_date}] Workshop {management_account_id}'
                    membership_name = membership_name[:49] # max length of 50

                    try:
                      if event["RequestType"] == "Create": 
                        client.create_membership(membershipName=membership_name, incidentResponseTeam=[person1, person2], optInFeatures=opt_in_features)
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                      elif event["RequestType"] == "Update":
                        response = client.list_memberships(maxResults=1)
                        membership_id = response['items'][0]['membershipId']
                        client.update_membership(membershipId=membership_id, membershipName=membership_name, incidentResponseTeam=[person1, person2], optInFeatures=opt_in_features)
                        print(f"Updating membership {membership_id}")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                      elif event["RequestType"] == "Delete":
                        response = client.list_memberships(maxResults=1)
                        membership_id = response['items'][0]['membershipId']
                        client.cancel_membership(membershipId=membership_id)
                        print("Leaving params and removing resource")
                        cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event["LogicalResourceId"])
                      else:
                        raise ValueError("Invalid request type: %s" % event["RequestType"])
                    except Exception as e:
                      print(f"An error occurred: {e}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)}, None)